# BS Series Precision Voltage Source (BS 34-1A)
It adds initial support for the **Stahl Electronics BS 34-1A** multichannel voltage source 
to the labscript suite.

Commands are sent via a standard serial interface with standard baud rate = 9600. 

---
## Timing Strategy
Since the BS 34-1A has no internal clock and no buffering, 
time-sensitive operations (e.g., updating voltages across a sequence) are 
implemented using `time.sleep(t)` in a background thread, opened in `transition_to_buffered`. 
After the whole sequence is done, the thread is closed in `transition_to_manual`.

While this is a naive approach, it currently works to avoid blocking
the main thread. 
However, we acknowledge that this is not ideal, and we welcome proposals for 
a cleaner, event-driven timing model.

---

## GUI small extension on button
A "Send to Device" button that:

  * Collects all entered voltages
  * Queues them into the worker process
  * Sends commands serially to the device

---

## BS 34-1A Emulator
This [emulator](testing/emulateSerPort.py) 
simulates the behavior of the BS 34-1A multichannel voltage source. 
It allows for testing with BLACS. When started, the emulator creates
a **virtual serial port** that behaves like a real BS 34-1A device. 
Programs can connect to this port and communicate with it as if 
it were the real device.

To launch the emulator:

```bash
python3 -m BS_Series.testing.emulateSerPort
```
You’ll see output like: For BS 34-1A use: /dev/pts/5

Use that port when connecting in `connection_table.py`. 

---

## Current implementation

The current implementation consists the standard implementation and tailored implementation 
to the specific BS 34-1A unit we own, which has the following configuration:

| Channel | Voltage Range |
| ------- |---------------|
| CH1     | ±24 V         |
| CH2–CH8 | ±34.565 V     |

We are modeling this modular support similar to how `NI_DAQmx` handles multiple device types.

---
## Connection table

```python
from labscript import start, stop, add_time_marker, AnalogOut, DigitalOut
from labscript_devices.DummyPseudoclock.labscript_devices import DummyPseudoclock
from labscript_devices.BS_Series.models.BS_341A_spec import BS_341A_spec
from labscript_devices.BS_Series.models.BS_341A import BS_341A

DummyPseudoclock(name='pseudoclock')
BS_341A_spec(name='voltage_source_for_ST', parent_device=pseudoclock.clockline, port='/dev/ttyUSB0', baud_rate=9600, num_AO=8)
BS_341A(name='voltage_source', parent_device=pseudoclock.clockline, port='/dev/pts/2', baud_rate=9600)

AnalogOut(name='ao_BS_1', parent_device=voltage_source_for_ST ,connection='ao 1')
AnalogOut(name='ao_BS_2', parent_device=voltage_source_for_ST ,connection='ao 2')
AnalogOut(name='ao_BS_3', parent_device=voltage_source_for_ST ,connection='ao 3')
AnalogOut(name='ao_BS_4', parent_device=voltage_source_for_ST ,connection='ao 4')
AnalogOut(name='ao_BS_5', parent_device=voltage_source_for_ST ,connection='ao 5')
AnalogOut(name='ao_BS_6', parent_device=voltage_source_for_ST ,connection='ao 6')
AnalogOut(name='ao_BS_7', parent_device=voltage_source_for_ST ,connection='ao 7')

AnalogOut(name='ao_BS_11', parent_device=voltage_source ,connection='ao 1', default_value=20)
AnalogOut(name='ao_BS_22', parent_device=voltage_source ,connection='ao 2')
AnalogOut(name='ao_BS_33', parent_device=voltage_source ,connection='ao 3')
AnalogOut(name='ao_BS_44', parent_device=voltage_source ,connection='ao 4')
```
---

## Extensions

This is the first device in the BS series we've integrated. 
Others in the same family are expected to have similar interfaces but may differ in:

* Voltage ranges per channel
* Number of channels
* Supported commands
* etc.

The plan is to extend current BS_ implementation by using subclassing and 
extending the configurations in [capabilities.json](models/capabilities.json).
In details: 

To add a new device, the user should:
- Define the new device model in the capabilities.json file.
- Create a corresponding .py file (by copying an existing model as a template).
- Adjust the class and the model names in .py file to match the new entry in the JSON file.

Note: The class name must exactly match the model name specified in capabilities.json.

---
